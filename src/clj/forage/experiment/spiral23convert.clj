;; For processing xls/csv data generated by spiral23.clj and
;; converting it into a tech.ml.dataset (TMD) dataset.
;; This was then written into a nippy file.
(ns forage.experiment.spiral23convert
  (:require [utils.csv :as csv]
            [tech.v3.dataset :as ds]))

(def home (System/getenv "HOME"))
(def fileloc "/docs/src/data.foraging/forage/spiral23/")
(def infilename "spiral23configs28runs4KdataFreshFromClojure.csv")
(def infilepath (str home fileloc infilename))
(def outfilename "spiral23configs28runs4Kdataset.nippy")
(def outfilepath (str home fileloc outfilename))

(defn convert-one-config
  "Converts a pair of rows into a TMD dataset for a single pair of
  configuration parameters.  The config name strings will be pulled from
  the first tow, and will then be repeated in every output row, while the
  lengths (first row) and found counts (second row) may be different in
  each row.  See convert-to-ds for more info."
  [two-rows]
  (if (not= (count two-rows) 2)
    (println "More or fewer than two rows in argument to convert-one-confg:" (count two-rows))
    (let [data-columns (map (partial drop 5) two-rows) ; remove config tags, leave data columns
          runs (count (nth data-columns 0)) ; how many runs in these two rows?
          length-row (nth data-columns 0) ; lengths and found counts are in
          found-row  (nth data-columns 1) ; alternating rows
          walk (nth (nth two-rows 0) 1)   ; walk structure config name
          env  (nth (nth two-rows 0) 2)]   ; environment name
      (ds/->dataset {:env  (repeat runs env)
                     :walk (repeat runs walk)
                     :length length-row
                     :found  found-row}))))

(defn convert-to-ds
  "Convert input from spiral23 data with (a) a header row, and (b)
  alternating length and found count rows, with config name strings in the
  length row, into a TMD dataset with columns :env, :walk, :length, and
  :found.  The first two identify configuration parameters (so the names
  are repeated in many rows), while the last two are output data from each
  run: a path length, and 0 or 1 to indicate the number of foodspots found."
  [csv]
  (->> csv
       (next) ; strip header row
       (partition 2) ; split into a collection of double-rows, each with length row and found row
       (map convert-one-config) ; convert each double row into a dataset for a single configuration
       (apply ds/concat-copying))) ; combine the single-config datasets into one dataset
       ;; tip: don't use clojure.core/merge-with

(comment
  ;; traditional version
  (defn convert-to-ds-trad
    [csv]
    (let [headless (next csv) ; strip header row
          two-rows-coll (partition 2 headless) ; split into a collection of double-rows, each with length row and found row
          datasets (map convert-one-config two-rows-coll)] ; convert each double row into a dataset for a single configuration
      (apply ds/concat-copying datasets))) ; combine the single-config datasets into one dataset
)

(comment

  (def rawinput (csv/slurp-csv infilepath)) ;; numbers are treated as strings
  ;; this is kludgey.  Might be better to use Java Long and Double classes:
  (def input (map #(map csv/number-or-string %) rawinput))

  (def spiral23-ds (convert-to-ds input))

  ;; sanity checks:
  (count input)
  (distinct (:env spiral23-ds))  ; Should be env0, env1, env2, env3
  (distinct (:walk spiral23-ds)) ; There should be seven strings
  (ds/descriptive-stats spiral23-ds)

  ;; Save the dataset as a nippy file:
  (ds/write! spiral23-ds outfilepath)

)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OLD TESTS/EXPERIMENTS
(comment 

  (def ds1 (ds/->dataset {:a [1 2 3] :b ["w" "x" "y"]}))
  (def ds2 (ds/->dataset {:a [4 5 6] :b ["a" "b" "c"]}))
  ;; Seems like it should work but doesn't:
  (def dsbad1 (merge-with concat ds1 ds2))
  ;; Not this:
  (def dsbad2 (ds/->>dataset [ds1 ds2]))
  ;; This concats as intended:
  (def ds (ds/concat-copying ds1 ds2))
  ;; There's also concat-inplace

  (def headless (next csv)) ; throw out the header row
  (count headless)
  (def data-columns (map (partial drop 5) headless)) ; remove config tags, leave data columns
  (def runs-per-config (count (nth data-columns 0))) ; how many runs in first row?

  (map #(nth % 2) headless)

  ;; first experiment:
  (def length-row (nth data-columns 0)) ; lengths and found counts are in
  (def found-row  (nth data-columns 1)) ; alternating rows
  (def walk (nth (nth headless 0) 1))   ; walk structure config name
  (def env  (nth (nth headless 0) 2))   ; environment name

  (def config0-ds (ds/->dataset {:walk (repeat runs-per-config walk)
                                 :env  (repeat runs-per-config env)
                                 :length length-row
                                 :found  found-row}))

  (class config0-ds)
  (count config0-ds)
  (vals config0-ds)
  (ds/descriptive-stats config0-ds 
                        {:stat-names [:col-name :datatype :min :mean :max :standard-deviation]})

  (def test-ds1 (convert-one-config (take 2 (next headless))))
  (def test-ds2 (convert-one-config (take 2 (drop 2 (next headless)))))
  (def test-ds3 (convert-one-config (take 2 (drop 4 (next headless)))))
  (class test-ds3)
  (map #(ds/descriptive-stats %) [test-ds1 test-ds2 test-ds3])

  (def test-ds (merge-with into test-ds1 test-ds2 test-ds3))
  (ds/descriptive-stats test-ds)


  (ds/write! spiral23-ds "yo.csv")
  (ds/write! spiral23-ds "yo.csv.gz")
  (ds/write! spiral23-ds "yo.csv.zip")
  (ds/write! spiral23-ds "yo.nippy") ; https://github.com/taoensso/nippy

  (def fromcsv (time (ds/->dataset "yo.csv")))
  (def fromcsvgz (time (ds/->dataset "yo.csv.gz")))
  (def fromcsvzip (time (ds/->dataset "yo.csv.zip")))
  (def fromnippy (time (ds/->dataset "yo.nippy")))
  (= spiral23-ds fromcsv) ; this is false, but 
  (ds/descriptive-stats fromcsv) ; this output looks the same
  (= spiral23-ds fromcsvgz) ; false
  (ds/descriptive-stats fromcsvgz)
  (= spiral23-ds fromcsvzip) ; false
  (ds/descriptive-stats fromcsvzip)
  (= spiral23-ds fromnippy) ; false? true?
  (ds/descriptive-stats fromnippy)

  (= fromcsv fromcsvgz) ; true, which makes sense
  (= fromcsv fromcsvzip) ; true, which makes sense
  (= fromcsv fromnippy) ; false
  ;; If you display the datasets in the log window, fromcsv
  ;; uses strings as keys, while fromnippy uses keywords
  ;; as keys.  Which makes sense, since writing to a csv file
  ;; requires turning things into strings or numbers, whereas
  ;; nippy is a general Clojure serialization format.
  ;; BUT SEE the :key-fn option to ->dataset.

  (def fromcsvmap (into {} fromcsv))
  (class fromcsvmap)
  (= fromcsvmap fromcsv) ; true!

  (def fromnippymap (into {} fromnippy))
  (class fromnippymap)
  (= fromnippymap fromnippy) ; true!

  (= fromcsvmap fromnippymap) ; false
  ;; If you display the maps in the log window, fromcsvmap
  ;; uses strings as keys, while fromnippymap uses keywords
  ;; as keys.  Which makes sense, since writing to a csv file
  ;; requires turning things into strings or numbers, whereas
  ;; nippy is a general Clojure serialization format.

  ;; replace string keys with keyword keys:
  (def keyfixcsvmap (zipmap (map keyword (keys fromcsvmap)) (vals fromcsvmap)))
  (= keyfixcsvmap fromnippymap) ; true: these are equal

)
