;; Functions for generating random walks.
;; (Code s/b independent of MASON and plot libs (e.g. Hanami, Vega-Lite).)
(ns forage.walks
    (:require [utils.math :as m]
              [utils.random :as r]
              [clojure.math.numeric-tower :as nt]))


(declare x-zero? y-zero? either-zero? both-zero?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; RANDOM WALKS

(defn step-vector-fn
  "Returns a function of no arguments that returns a random mathematical 
  vector in the form of pair containing a direction dir, in radians, and a
  length len.  dir is uniformly distributed in [0,2pi] using PRNG instance 
  rng, and length is distributed according to distribution instance dist.
  If low and high arguments are given, the distribution is truncated so that
  lengths fall within [low, high].  (These vectors represent steps going from
  one \"stop\" to the next in a random walk.)  Example use:
    (def step-vecs (repeatedly 
                     (step-vector-fn (make-well19937)
                                     (make-powerlaw 1 2)
                                     1 100)))"
  ([rng dist] (fn [] [(r/next-radian rng) (r/next-double dist)]))
  ([rng dist low high]
   (fn [] [(r/next-radian rng) (r/next-double dist low high)])))

(defn subst-init-dir
  "Given a sequence step-seq of step vectors, i.e. [direction length] pairs,
  return a sequence that's the same except that the direction of the first 
  vector has been replaced by init-dir."
  [init-dir step-seq]
  (let [firststep  (vec (first step-seq))
        othersteps (rest step-seq)
        newstep    (assoc firststep 0 init-dir)]
    (cons newstep othersteps)))


;; I probably don't need both of the next two:

(defn vecs-upto-len
  "Given a desired total path length, and a sequence of step vectors, returns 
  a sequence of vectors, from the front of the sequence, whose lengths sum to 
  at least desired-total.  By default, the lengths are made to sum to exactly
  desired-total by reducing the length in the last step vector.  Add 
  ':trim false' or ':trim nil' to return a sequence with the last vector as it
  was in the input vecs sequence."
  [desired-total vecs & {trim :trim :or {trim true}}]
  (reduce 
    (fn [[tot-len out-vecs] [dir len :as v]]
        (if (< tot-len desired-total)          ; if not yet reached total
          [(+ tot-len len) (conj out-vecs v)]  ; keep conj'ing
          (reduced                             ; otherwise
            (if trim   ; by default shorten last len so tot-len = desired-total
              (let [overshoot (- tot-len desired-total) ; how much > desired?
                    [old-dir old-len] (last out-vecs)
                    newlast [old-dir (- old-len overshoot)]] ; subtract extra
                (conj (vec (butlast out-vecs)) newlast)) ; replace old last
              out-vecs)))) ; return constructed seq as is if trim was falsey
    [0 []]
    vecs))

;; Instead of the following, one could use 
;; (count (vecs-upto-len desired-total vecs))
;; This version is more efficient if you don't yet want to separate out 
;; the relevant vecs, but then you might have to trim the last element
;; later.  I might delete count-vecs-upto-len later.
(defn count-vecs-upto-len
  "Given a desired total path length, and a sequence of step vectors,
  returns the number of steps needed to sum lengths to at least 
  desired-total."
  [desired-total vecs]
  (reduce (fn [[tot-len cnt] [_ len]]
            (if (< tot-len desired-total)
              [(+ tot-len len) (inc cnt)]
              (reduced cnt)))
          [0 0]
          vecs))

(defn next-walk-stop
  "Given a mathematical vector in the form of a direction in radians
  and a length, and (a vector in the form of) a coordinate pair, returns 
  a new coordinate pair that's the result of adding the first vector
  to the second.  (This is the next \"stop\" in a walk.)"
  [[dir len] [prevx prevy]]
  (let [[vecx vecy] (m/rotate dir [len, 0]) ; rotate vector lying on x-axis
        nextx (+ prevx vecx)  ; add vector to prev point
        nexty (+ prevy vecy)]
    [nextx nexty]))

(defn walk-stops
  "Generates a (possibly infinite) sequence of next points from an 
  initial-point and a (possibly infinite) sequence of [direction, length]
  vectors, using each in turn, adding it to the previous point.  
  (These points are the \"stops\" in a random walk.)
  Example use, where step-vecs has been generated by repeated calls to 
  next-walk-fn:
     (walk-stops [0 0] step-vecs)"
  [prevpt step-vectors]
  (lazy-seq 
    (let [nextpt (next-walk-stop (first step-vectors) prevpt)]
      (cons prevpt (walk-stops nextpt (rest step-vectors))))))
