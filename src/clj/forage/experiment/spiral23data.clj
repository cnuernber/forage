;; For processing xls/csv data generated by spiral23 into tech.ml.dataset
;; structures.
(ns forage.experiment.spiral23data
  (:require [utils.csv :as csv]
            [tech.v3.dataset :as ds]
            [tech.v3.datatype.functional :as dsf]
            [tablecloth.api :as tc]
            ;[forage.core.run :as fr]
            ;[utils.math :as um]
  ))

(def home (System/getenv "HOME"))
(def fileloc "/docs/src/data.foraging/forage/spiral23/")
(def filename "spiral23configs28runs4KdataFreshFromClojure.csv")
(def filepath (str home fileloc filename))

(comment

  (def rawcsv (csv/slurp-csv filepath)) ;; numbers are treated as strings
  ;; this is kludgey.  Might be better to use Java Long and Double classes:
  (def csv (map #(map csv/number-or-string %) rawcsv))
  (count csv)

  (defn convert-one-config
    [two-rows]
    (if (not= (count two-rows) 2)
      (println "More or fewer than two rows in argument to convert-one-confg:" (count two-rows))
      (let [data-columns (map (partial drop 5) two-rows) ; remove config tags, leave data columns
            runs (count (nth data-columns 0)) ; how many runs in these two rows?
            length-row (nth data-columns 0) ; lengths and found counts are in
            found-row  (nth data-columns 1) ; alternating rows
            walk (nth (nth two-rows 0) 1)   ; walk structure config name
            env  (nth (nth two-rows 0) 2)]   ; environment name
        (ds/->dataset {:walk (repeat runs walk)
                       :env  (repeat runs env)
                       :length length-row
                       :found  found-row}))))


  ;; threading version
  (defn convert-to-ds-thread
    [csv]
    (->> csv
         (next) ; strip header row
         (partition 2) ; split into a collection of double-rows, each with length row and found row
         (map convert-one-config) ; convert each double row into a dataset for a single configuration
         (apply ds/concat-copying))) ; combine the single-config datasets into one dataset

  ;; traditional version
  (defn convert-to-ds
    [csv]
    (let [headless (next csv) ; strip header row
         two-rows-coll (partition 2 headless) ; split into a collection of double-rows, each with length row and found row
         datasets (map convert-one-config two-rows-coll)] ; convert each double row into a dataset for a single configuration
      (apply ds/concat-copying datasets))) ; combine the single-config datasets into one dataset
      ;; tip: clojure.core/merge-with won't work here.

  (def spiral23-ds (convert-to-ds csv))
  (def spiral23-ds2 (convert-to-ds-thread csv))
  (= spiral23-ds spiral23-ds2)
  (class spiral23-ds)

  (ds/descriptive-stats spiral23-ds)
  (distinct (:env spiral23-ds))
  (distinct (:walk spiral23-ds))

  (ds/write! spiral23-ds "yo.csv")

)


(comment ;; OLD TESTS/EXPERIMENTS

  (def ds1 (ds/->dataset {:a [1 2 3] :b ["w" "x" "y"]}))
  (def ds2 (ds/->dataset {:a [4 5 6] :b ["a" "b" "c"]}))
  ;; Seems like it should work but doesn't:
  (def dsbad1 (merge-with concat ds1 ds2))
  ;; Not this:
  (def dsbad2 (ds/->>dataset [ds1 ds2]))
  ;; This concats as intended:
  (def ds (ds/concat-copying ds1 ds2))
  ;; There's also concat-inplace

  (def headless (next csv)) ; throw out the header row
  (count headless)
  (def data-columns (map (partial drop 5) headless)) ; remove config tags, leave data columns
  (def runs-per-config (count (nth data-columns 0))) ; how many runs in first row?

  (map #(nth % 2) headless)

  ;; first experiment:
  (def length-row (nth data-columns 0)) ; lengths and found counts are in
  (def found-row  (nth data-columns 1)) ; alternating rows
  (def walk (nth (nth headless 0) 1))   ; walk structure config name
  (def env  (nth (nth headless 0) 2))   ; environment name

  (def config0-ds (ds/->dataset {:walk (repeat runs-per-config walk)
                                 :env  (repeat runs-per-config env)
                                 :length length-row
                                 :found  found-row}))

  (class config0-ds)
  (count config0-ds)
  (vals config0-ds)
  (ds/descriptive-stats config0-ds 
                        {:stat-names [:col-name :datatype :min :mean :max :standard-deviation]})

  (def test-ds1 (convert-one-config (take 2 (next headless))))
  (def test-ds2 (convert-one-config (take 2 (drop 2 (next headless)))))
  (def test-ds3 (convert-one-config (take 2 (drop 4 (next headless)))))
  (class test-ds3)
  (map #(ds/descriptive-stats %) [test-ds1 test-ds2 test-ds3])

  (def test-ds (merge-with into test-ds1 test-ds2 test-ds3))
  (ds/descriptive-stats test-ds)
)
