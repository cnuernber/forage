(ns forage.core-test
  (:require [clojure.test :refer :all]
            [forage.viz.toroidal :as tor]))

(def coordinates-for-toroidal-tests
  (apply concat [(map vector (range 5) (range 20 25)) (map vector (range 10 20) (range 100 110)) (map vector (range 7 14) (range 21 28)) (map vector (range 18 25) (range 9 16)) (map vector (range 7 16) (range 200 209))])) 

(def toroidal-wrapped-partition-expected-result
  [[[0 0] [1 1] [2 2] [3 3] [4 4] [4 0]]
   [[4 0] [5 1] [0 2]]
   [[0 2] [1 3] [2 4] [3 5] [4 6] [5 7] [0 8]]
   [[0 8] [1 9] [1 1]]
   [[1 1] [2 2] [3 3] [4 4] [5 5] [0 6]]
   [[0 6] [1 7] [0 9]]
   [[0 9] [1 10] [2 11] [3 12] [4 13] [5 14] [0 15]]
   [[0 15] [1 0]]
   [[1 0] [2 1] [3 2] [4 3] [5 4] [0 5]]])

(deftest toroidal-wrapped-partition
  (testing "toroidal-wrapped-partition"
           (let [result (tor/toroidal-wrapped-partition
                          12 40 coordinates-for-toroidal-test)]
             (is (= result toroidal-wrapped-partition-expected-result)
                 "toroidal-wrapped-partition"))))


;; Tests from earlier repo foond.  Might be useful to adapt here.  or not.
(comment
;; To test foond.space/walk-pairs, I'm using two older versions of the
;; same functionality.  Maybe silly to use both of them, but 
;; what the heck--they're already written.

(defn finite-walk-pairs
  "Computes a sequence of next points from an initial-point 
  and a sequence of [direction, length] vectors, using each in turn, adding
  it to the previous point.  walk-vectors must be finite.
  Example use, where vs has been generated by repeated calls to next-walk-fn:
     (walk-pairs [0 0] (take 50 vs)))"
  [initial-point walk-vectors]
  (reduce 
    (fn [pairs vect]
        (conj pairs (s/next-walk-pair vect (last pairs))))
    [initial-point] ; a seq of a seq
    walk-vectors))

(defn standalone-next-walk-pair
  "Computes next point from [prevx prevy] by internally 
  generating next direction and length using rng for uniform distribution
  over directions, and using dist, truncated to fall within low and high,
  to generate step length.  Then adds the resulting vector  to [prevx prevy].
  Example use:
     (iterate (partial s/standalone-next-walk-pair rng dist 0 100) [0 0])"
  [rng dist low high [prevx prevy]]
  (let [dir (r/next-radian rng)  ; direction of new step vector
        len (r/next-double dist low high) ; length of new step vector
        [vecx vecy] (m/rotate dir [len, 0]) ; rotate vector along x-axis
        nextx (+ prevx vecx)  ; add vector to prev point
        nexty (+ prevy vecy)]
    [nextx nexty]))

(def pair-count 10)

(deftest walk-pairs
  (testing "walk-pairs"
           (let [RNG1 (r/make-well19937 12345) ; make sure independent test runs start from same PRNG state
                 RNG2 (r/make-well19937 12345)
                 DIST1 (r/make-powerlaw (r/make-well19937 67891) 1 2) ; could use rng1
                 DIST2 (r/make-powerlaw (r/make-well19937 67891) 1 2) ; could use rng2
                 standalone-pairs (take pair-count (iterate (partial standalone-next-walk-pair ; one test set
                                                              RNG1 DIST1 1 100) [0 0]))
                 step-vecs (repeatedly (s/walk-vector-fn RNG2 DIST2 1 100))
                 finite-pairs (finite-walk-pairs [0 0] (take (dec pair-count) step-vecs)) ; the other, identical test set
                 pairs (take pair-count (s/walk-pairs [0 0] step-vecs))] ; the real set to test
             (is (= pairs finite-pairs) "walk-pairs vs. finite outputs")
             (is (= pairs standalone-pairs) "walk-pairs vs. standalone outputs" )))) ; doing this again is overkill, but wth
)
